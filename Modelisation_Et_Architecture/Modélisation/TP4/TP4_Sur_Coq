Require Extraction.
Section Induction.
Variable A : Set.
Inductive liste : Set :=
      Nil    : liste
      | Cons : A -> liste -> liste.
Variable append_spec : liste -> liste -> liste.
Axiom append_Nil : forall (l : liste), append_spec Nil l = l.
Axiom append_Cons : forall (t : A), forall (q l : liste),append_spec (Cons t q) l = Cons t (append_spec q l).

Theorem append_Nil_right : forall (l : liste), (append_spec l Nil) = l.
intro l. (* on introduit l'hypothèse l *)
induction l. (* on fait une récurrence généralisée sur la variable l *)
rewrite append_Nil. (* on applique l'axiome append_Nil *)
reflexivity. (* permet de conclure lorque l'on a l=l par ex *)
rewrite append_Cons. (* on applique l'axiome append_Cons *)
rewrite IHl. (* on applique l'hypothèse nommée IHL *)
reflexivity.
Qed.

Theorem append_associative : forall (l1 l2 l3 : liste),(append_spec l1 (append_spec l2 l3)) = (append_spec (append_spec l1 l2) l3).
intros l1 l2 l3.
induction l1.
rewrite append_Nil.
rewrite append_Nil.
reflexivity.
rewrite append_Cons. 
rewrite append_Cons.
rewrite append_Cons.
rewrite IHl1.
reflexivity.
Qed.

Fixpoint append_impl (l1 l2 : liste) {struct l1} : liste :=
match l1 with
Nil => l2
| (Cons t1 q1) => (Cons t1 (append_impl q1 l2))
end.

Theorem append_correctness : forall (l1 l2 : liste),(append_spec l1 l2) = (append_impl l1 l2).
intros l1 l2.
induction l1.
rewrite append_Nil.
simpl. (* permet d'appliquer rewrite append_impl*)
reflexivity.
rewrite append_Cons.
rewrite IHl1.
simpl.
reflexivity.
Qed.


Fixpoint rev_impl (l1 : liste) {struct l1} : liste :=
match l1 with
Nil => Nil
| (Cons t1 l1) => (append_impl (rev_impl l1) (Cons t1 Nil))
end.  


Lemma rev_append : forall (l1 l2 : liste),(rev_impl (append_impl l1 l2)) = (append_impl (rev_impl l2) (rev_impl l1)).
intros l1 l2.
induction l1.
simpl.
rewrite <- append_correctness. (* change append_impl en append_spec, la flèche indique que la transformation se fait dans le sens <-, vis à vis du théorème utilisé *)
rewrite append_Nil_right.
reflexivity.
simpl. (* commande rapide pour rewrite append_impl *)
rewrite IHl1.
rewrite <- append_correctness.
rewrite <- append_correctness.
rewrite <- append_correctness.
rewrite <- append_correctness.
rewrite append_associative.
reflexivity.
Qed.


Theorem rev_rev : forall (l : liste), (rev_impl (rev_impl l)) = l.
intro l.
induction l.
simpl. (* ici cette commande fait appel à rev_impl *)
reflexivity.
simpl.
rewrite rev_append.
rewrite IHl.
simpl. (* ici cette commande fait appel à rev_impl *)
reflexivity.
Qed.



End Induction.

Extraction Language OCaml.
Extraction "/tmp/induction" append_impl rev_impl.
Extraction Language Haskell.
Extraction "/tmp/induction" append_impl rev_impl.
Extraction Language Scheme.
Extraction "/tmp/induction" append_impl rev_impl.


Recursive Extraction append_impl.

