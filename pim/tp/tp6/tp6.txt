Exercice 1
gnatmake -gnatwa -gnata -g exemples_memoire_dynamique.adb
./exemples_memoire_dynamique
-gnata -> Assertions enables Pragma assert to be activated
-g -> generate debugging information

Exercice 2
malloc signifie mauvaise allocation, il faut déplier les petites fl_èches pour voir les erreurs, soit les éléments en bleu, qui correspondent aux parties du code où il y a des erreurs. 
bytes signifie qu'il y a des fuites de mémoire. 
Rajouter Free(Ptr1)
Il faut alors recompiler le .adb:
gnatmake -gnatwa -gnata -g exemples_memoire_dynamique.adb
valkyrie ./exemples_memoire_dynamique

Exercice 3
procedure Illustrer_Memoire_Dynamique_Erreur is

                 Ptr1, Ptr2 : T_Pointeur_Integer;
         begin
                 Ptr1 := new Integer;
                 Ptr2 := Ptr1;             -- on a deux noms différents pour la même adresse mémoire, on peut les     manipuler indépendemment.
                 Ptr1.all := 5;
                 pragma Assert (Ptr1.all = 5);
                 pragma Assert (Ptr2.all = 5);

                 Free (Ptr1);

                 pragma Assert (Ptr1 = Null);    -- le pointeur est bien mis à Null
                 pragma Assert (Ptr2 /= Null);

                 -- XXX Quelle est la valeur de Ptr2.all ? La case mémoire a été libérée, renvoie une valaur, mais     on s'en fiche, car comme cela a été libéré, c'est libre pour l'ordi.
                 Put_Line ("Ptr2.all = " & Integer'Image (Ptr2.all));

                 Ptr2.all := 7;
                 pragma Assert (Ptr2.all = 7);
                 Put_Line ("Ptr2.all =" & Integer'Image(Ptr2.all));
                 -- XXX A-t-on le droit de manipuler Ptr2.all ? Non car l'espace mémoire a été libéré
-- XXX Que se passe-t-il si on exécute le programme avec valkyrie ? Il va y avoir une erreur car     on a pas libéré l'espace mémoire associée à Ptr2.
                 --
                  -- Le terme "Unchecked" dans Unchecked_Deallocation vient de là.  Ada
                  -- n'a pas de moyen de contrôler que quand on libère de la mémoire il
                  -- n'y a plus aucun pointeur dans le programme qui la référence.  C'est
                  -- à la charge du programmeur !  Utiliser un ramasse-miettes (garbage
                  -- collector) résoud ce problème car il ne libèrera la mémoire que s'il
                  -- n'y a plus aucune référence dessus.
          end Illustrer_Memoire_Dynamique_Erreur;

Exercice 4
Lorsque l'on a Ptr.all = 111
et que l'on fait Ptr.all := 123
Alors cela renvoie, pour Ptr.all, 123. 

Exercice 5
1. Comme la mémoire qu'occupe P sera libérée à la fin du sous-programme (car variable locale), on peut se passer de Detruire, qui consiste justement à libérer la mémoir edynamique utilisée. 

Exercice 6
2. Il s'affiche: 
Ptr1.all =  5
Ptr1.all =  5
Ptr2.all =  0
valeur de Ptr.all ?  123
Sommet =  4

raised STORAGE_ERROR : stack overflow or erroneous memory access

Cette dernière ligne signifie qu'il y a un pb de gestion de mémoire.

3. On commente les trois lignes suivantes: 
Put_Line ("Ptr2.all = " & Integer'Image (Ptr2.all));
Ptr2.all := 7;
pragma Assert (Ptr2.all = 7);

4. On associe pas deux pointeurs différents à la même adresse mémoire. 

Exercice 7

